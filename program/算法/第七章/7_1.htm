<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=gb_2312-80">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>第 2 章  线性表</TITLE>
</HEAD>
<BODY>

<B><FONT SIZE=3><P ALIGN="JUSTIFY">1. </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>构造图的邻接矩阵算法</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">    Status</B>  CreatGraph ( MGraph  <B>&amp;</B>G )  </FONT><B><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>{&#9;&#9;&#9;</B></FONT><FONT SIZE=3>// </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>采用邻接矩阵表示法构造图</FONT><FONT SIZE=3> <I>G</P>
</I><P ALIGN="JUSTIFY">      <B>scanf</B> ( <B>&amp;</B>G.kind );</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;&#9;&#9;&#9;&#9;&#9;&#9;</FONT><FONT SIZE=3>// </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>输入图的种类</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">      <B>switch</B> ( G.kind )  </FONT><B><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>{</P>
</B></FONT><FONT SIZE=3><P ALIGN="JUSTIFY">        <B>case</B>  DG  <B>:</B>  <B>return</B>  CreatDG ( G );&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;</FONT><FONT SIZE=3>// </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>构造有向图</FONT><FONT SIZE=3> <I>G</P>
</I><P ALIGN="JUSTIFY">        <B>case</B>  DN  <B>:</B>  <B>return</B>  CreatDN ( G );</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;&#9;</FONT><FONT SIZE=3>// </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>构造有向网</FONT><FONT SIZE=3> <I>G</P>
</I><P ALIGN="JUSTIFY">        <B>case</B>  UDG <B>:</B>  <B>return</B>  CreatUDG ( G );&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;</FONT><FONT SIZE=3>// </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>构造无向图</FONT><FONT SIZE=3> <I>G</P>
</I><P ALIGN="JUSTIFY">        <B>case</B>  UDN <B>:</B>  <B>return</B> CreatUDN ( G );</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;&#9;</FONT><FONT SIZE=3>// </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>构造无向网</FONT><FONT SIZE=3> <I>G</P>
</I><P ALIGN="JUSTIFY">        <B>default</B> </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;</FONT><FONT SIZE=3>  <B>:</B>  <B>return</B> ERROR;</P>
<P ALIGN="JUSTIFY">      </FONT><B><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>}</B></FONT><FONT SIZE=3> // switch </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>结束</P>
<B><P ALIGN="JUSTIFY">}</B></FONT><FONT SIZE=3> // CreatGraph</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
</FONT><B><FONT SIZE=3><P ALIGN="JUSTIFY">Status</B>  CreatUDN ( MGraph  <B>&amp;</B>G )  </FONT><B><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>{&#9;&#9;&#9;</B></FONT><FONT SIZE=3>// </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>采用邻接矩阵表示法，构造无向网</FONT><FONT SIZE=3> <I>G</P>
</I><P ALIGN="JUSTIFY">      <B>scanf</B> ( <B>&amp;</B>G.vexnum,  &amp;G.arcnum,  &amp;IncInfo );</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">  // </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>输入顶点数和弧树，如果</FONT><FONT SIZE=3> <I>IncInfo</I> </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为</FONT><FONT SIZE=3> 0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，则各弧不含其他信息</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">    </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;</FONT><FONT SIZE=3>  <B>for</B> ( i = 0;  i &lt; G.vexnum;  ++i )</P>
<P ALIGN="JUSTIFY">        </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;</FONT><B><FONT SIZE=3>scanf</B> ( <B>&amp;</B>G.vexs[i] );&#9;&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;&#9;&#9;</FONT><FONT SIZE=3>// </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>构造顶点向量</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">    </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;</FONT><FONT SIZE=3>  <B>for</B> ( i = 0;  i &lt; G.vexnum;  ++i )&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;&#9;</FONT><FONT SIZE=3>// </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>初始化邻接矩阵</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">        </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;</FONT><B><FONT SIZE=3>for</B> ( j = 0;  j &lt; G.vexnum;  ++j )</P>
<P ALIGN="JUSTIFY">&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;</FONT><FONT SIZE=3>  G.arcs[i][j] = </FONT><B><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>{</B></FONT><FONT SIZE=3> INFINITY,  NULL </FONT><B><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>}</B></FONT><FONT SIZE=3>;  &#9;&#9;// <I>adj</I> = INFINITY</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，</FONT><I><FONT SIZE=3>info</I> = NULL</P>
<P ALIGN="JUSTIFY">     &#9;<B>for</B> ( k = 0;  k &lt; G.arcnum;  ++k )  </FONT><B><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>{&#9;&#9;&#9;</B></FONT><FONT SIZE=3>// </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>构造邻接矩阵</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">        </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;</FONT><FONT SIZE=3>  <B>scanf</B> ( <B>&amp;</B>v1, <B>&amp;</B>v2, <B>&amp;</B>w );      </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;&#9;&#9;&#9;</FONT><FONT SIZE=3>// </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>输入一条边依附的顶点及权值</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">        </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;</FONT><FONT SIZE=3>  i = LocateVex ( G, v1 );          </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;&#9;&#9;</FONT><FONT SIZE=3>// </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>确定</FONT><FONT SIZE=3> <I>v</I>1 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在</FONT><FONT SIZE=3> <I>G</I> </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中位置</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">        </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;</FONT><FONT SIZE=3>  j = LocateVex ( G, v2 );&#9;         </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;&#9;</FONT><FONT SIZE=3>// </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>确定</FONT><FONT SIZE=3> <I>v</I>2 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在</FONT><FONT SIZE=3> <I>G</I> </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中位置</P>
<P ALIGN="JUSTIFY">&#9;&#9;</FONT><B><FONT SIZE=3>while</B> ( i &lt; 1 <B>||</B> i &gt; G.vexnum <B>||</B> j &lt; 1 <B>||</B> j &gt; G.vexnum)  </FONT><B><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>{</P>
</B><P ALIGN="JUSTIFY">&#9;&#9;</FONT><FONT SIZE=3>// </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>如果编号超出范围，重新输入弧的始点和终点，并确定它们在</FONT><FONT SIZE=3> <I>G</I> </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的位置</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">        </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;</FONT><FONT SIZE=3>  <B>scanf</B> ( <B>&amp;</B>v1,  <B>&amp;</B>v2,  <B>&amp;</B>w );</P>
<P ALIGN="JUSTIFY">          i = LocateVex ( G, v1 );</P>
<P ALIGN="JUSTIFY">        </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;</FONT><FONT SIZE=3>  j = LocateVex ( G, v2 );</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">&#9;&#9;<B>}</B></FONT><FONT SIZE=3> // while </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>结束</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">          G.arcs[i][j].adj = w;&#9;         </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;&#9;&#9;</FONT><FONT SIZE=3>// </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>弧</FONT><FONT SIZE=3> &lt; <I>v</I>1, <I>v</I>2 &gt; </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的权值</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">        </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;</FONT><FONT SIZE=3>  <B>if</B> ( IncInfo )  <B>Input</B> ( *G.arcs[i][j].info );  </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;</FONT><FONT SIZE=3>// </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>若弧含有相关信息，则输入</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">        </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;</FONT><FONT SIZE=3>  G.arcs[j][i] = G.arcs[i][j];         </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;&#9;&#9;</FONT><FONT SIZE=3>// </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>置</FONT><FONT SIZE=3> &lt;<I>v</I>1, <I>v</I>2&gt; </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的对称弧</FONT><FONT SIZE=3> &lt;<I>v</I>2, <I>v</I>1&gt;</P><DIR>

</FONT><B><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">}</B></FONT><FONT SIZE=3> // for </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>结束</P></DIR>

</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">    </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>&#9;</FONT><FONT SIZE=3>  <B>return</B> OK;</P>
<B><P ALIGN="JUSTIFY">    </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>}</B></FONT><FONT SIZE=3> // CreatUDN</P></FONT></BODY>
</HTML>
