# 1 课题概述
## 1.1 课题任务
#### 【题目】
##### 哈夫曼压缩软件设计
#### 【问题描述】
##### 采用哈夫曼树求得的用于通信的二进制编码称为哈夫曼编码。利用哈夫曼编码对文本或图像进行数据压缩，设计数据压缩软件。
#### 【设计要求】
##### 设计基于哈夫曼编码的文本和图像压缩软件。
###### （1）采用静态链表的二叉树等数据结构。
###### （2）可以随机、文件及人工输入数据。
###### （3）创建哈夫曼树，生成哈夫曼编码和译码。
###### （4）源码、编码和压缩后的信息均以文件形式保存。
###### （5）可以查询和更新数据。
###### （6）其它完善性或扩展性功能。
## 1.2 课题原理
##### 压缩：把文本或文件的二进制形式每8位作为一个字节来统计每个字节的出现频率，根据这一信息建立哈夫曼树，把原来的编码转换为哈夫曼编码，再把哈夫曼编码转换为二进制形式存到文件中，同时存储哈夫曼树。
##### 解压：上述过程的逆过程。
## 1.3 相关知识
##### （1）哈夫曼编码
##### （2）最小堆
##### （3）哈希表

# 2 需求分析
## 2.1 课题调研
##### 在当今信息爆炸时代，如何采用有效的数据压缩技术节省数据 文件的存储空间和计算机网络的传送时间已越来越引起人们的重视， 哈夫曼编码正是一种应用广泛且非常有效的数据压缩技术。哈夫曼 编码是一种编码方式，以哈夫曼树—即最优二叉树，带权路径长度 最小的二叉树，经常应用于数据压缩。哈夫曼编码使用一张特殊的 编码表将源字符(例如某文件中的一个符号)进行编码。这张编码 表的特殊之处在于，它是根据每一个源字符出现的估算概率而建立 起来的(出现概率高的字符使用较短的编码，反之出现概率低的则 使用较长的编码，这便使编码之后的字符串的平均期望长度降低， 从而达到无损压缩数据的目的)。哈夫曼编码的应用很广泛，利用哈 夫曼树求得的用于通信的二进制编码称为哈夫曼编码。树中从根到 每个叶子都有一条路径，对路径上的各分支约定:指向左子树的分 支表示“0”码，指向右子树的分支表示“1”码，取每条路径上的 “0”或“1”的序列作为和各个叶子对应的字符的编码，这就是哈 夫曼编码。哈夫曼译码输入字符串可以把它编译成二进制代码，输 入二进制代码时可以编译成字符串。

## 2.2 用户需求分析
##### 压缩时用户提供的输入可以是文件或文本，其中文本要可以随机生成。输出是压缩文件和哈夫曼树文件；解压正好反过来。
##### 除了基本的压缩和解压功能，为了把哈夫曼算法可视化，在图形界面中还要显示出字节出现次数的情况和统计。

# 3 方案设计
## 3.1 总体功能设计
##### 要实现文本和文件的压缩和解压，并把过程可视化。
## 3.2 数据结构设计
##### （1）使用二叉链表树来实现哈夫曼树
```C++
//树的节点
class treeNode//哈夫曼树上的节点
{
public:
    int data,freq;//字节和其出现频率
    treeNode *lchild,*rchild;//左右儿子
    treeNode(int DATA,int FREQ)//节点的构造函数
    {
        this->data=DATA;
        this->freq=FREQ;
        this->lchild=NULL;
        this->rchild=NULL;
    }
};
```
##### （2）使用哈希表在程序中存取哈夫曼树
##### （3）用最小堆来生成哈夫曼树，最小堆用数组模拟树。
## 3.3 函数原型设计
### 3.1.1 哈夫曼树
```C++
class HuffTree
{
public:
    treeNode *root;//哈夫曼树的树根
    QByteArray toByteArray(QString&);//根据哈夫曼树吧一串哈夫曼编码转换为原始编码
    HuffTree(unordered_map<char,string>&);//根据每个字节和其编码构造哈夫曼树（解压时调用）
    HuffTree(unordered_map<char,int>&);//根据每个字符和其出现频率构造哈夫曼树（压缩时调用）
    ~HuffTree();//析构函数
    unordered_map<char,string>toHuffCode();//把当前哈夫曼树转换为哈夫曼编码
private:
    void FreeMem(treeNode*);//释放空间，供析构函数调用
    void DFS(unordered_map<char,string>&,treeNode*,string);//把当前这棵哈夫曼树转换为哈夫曼编码
    treeNode *join(treeNode*,treeNode*);//哈夫曼算法中把两个节点合并为一个的操作
};
```
### 3.1.2 最小堆
```C++
class MinHeap//最小堆定义
{
public:
    void push(treeNode *nodeptr);//向堆中加入元素
    treeNode *pop();//弹出堆顶元素
    int size();//返回堆中元素个数
private:
    int siz=0;//
    treeNode *heap[MIN_HEAP_SIZE];//数据域
    void MinimizeHeap(int i);//在删除节点后维护堆堆性质
    void MaintainHeap(int i);//在插入节点后维护堆堆性质
};
```
### 3.1.3 哈夫曼数据处理
```C++
////统计各个字节的出现次数
unordered_map<char,int>CountEachByte(const char*,int);
unordered_map<char,int>CountEachByte(QByteArray&);

//根据字节数量统计建立哈夫曼树并返回每个字符的哈夫曼编码
unordered_map<char,string>GetHuffCode(unordered_map<char,int>&);

//根据已经生成的哈夫曼树把数据编码为哈夫曼编码
//把哈夫曼编码以二进制形式储存并返回
//返回编码长度
int Encode(QByteArray&,unordered_map<char,string>&,const char*,int);

//把二进制方式储存的哈夫曼编码转换为“0,1”的字符串
QString Decode(const char*,int,int);

//把“0,1”字符串形式的哈夫曼编码转换回原来的文件并返回
QByteArray DeCompress(QString&,std::unordered_map<char,string>);
```
## 3.4 输入输出设计
### 3.4.1 输入
##### 为任意文件或文本，详见3.6。
### 3.4.2 输出
##### 为一个.hufzip文件和一个.huftree文件，分别是压缩文件和哈夫曼树文件，详见3.6。
## 3.5 主算法设计
### 3.5.1 哈夫曼树的生成
##### （1）先预处理出每个字符的频率，作为节点放进一个优先队列中。
##### （2）从优先队列中取出两个频率最小的节点，合并为一个新的节点，左右儿子分别为上述的两个家节点，新节点的频率为两个子节点频率之和，再把这个新节点插入优先队列。
##### （3）每次进行一次上述操作会使得优先队列中节点个数-1；重复上述操作直到队列中只剩一个节点，把这个节点作为哈夫曼树的树根。
### 3.5.2 压缩文件的生成
##### （1）把哈夫曼编码后的字符串转换成压入字节，若总字节数不能被8整除则在后面补0。
##### （2）储存时，先在目标文件中写入哈夫曼编码的长度，再写入数据。哈夫曼树直接以文件流的形式储存；格式为字节的种类数（上限为256），然后每一行是这个字节的十进制表示和string类型的“0”“1”串。
## 3.6 用户界面设计
#### 软件分为压缩和解压两种流程；压缩为从上到下，解压为从下到上。
##### （1）首先选择要压缩/解压的文件，可以通过弹窗浏览选择，也可以手动输入文件路径。
##### （2）压缩的时候，先选择来源的种类（文件或者文本），如果是文件的话点击fetch，程序会读取文件，并在上方的文本框中显示文件内容。接着再点击compress，程序会运行哈夫曼算法，在右边的表格中显示出每个字节的出现次数统计，并在下方的文本框中显示哈夫曼编码后的文件。
##### （3）点击save，程序会输出.hufzip文件和.huftree文件，分别是压缩文件和哈夫曼树文件。
##### （4）解压过程即上述过程的逆过程，先选择解压模式。再从下往上进行。

# 4 方案实现
## 4.1 开发环境与工具
##### （1）Qt 5.12
##### （2）clang12
##### （3）vscode
## 4.2 程序设计关键技术
##### （1）最小堆的实现
##### （2）构建哈夫曼树
##### （3）把哈夫曼树转化为二进制的哈夫曼编码
##### （4）把编码后的哈夫曼串解码
## 4.3 个人设计实现
### 4.3.1
### 4.3.2
### 4.3.3

# 5 测试与调试
## 5.1 个人测试
### 5.1.1
### 5.1.2
### 5.1.3
## 5.2 组装与系统测试
## 5.3 系统运行

# 6 课题总结
## 6.1 课题评价
## 6.2 团队协作
## 6.3 下一步工作
## 6.4 个人设计心得
### 6.4.1
### 6.4.2
### 6.4.3
